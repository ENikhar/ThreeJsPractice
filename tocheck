
import * as THREE from 'three';
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 20);

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);
const controls = new OrbitControls(camera, renderer.domElement);

const origin = new THREE.Vector2(-1, -1);
console.log(origin.x, origin.y);

const height = 2, width = 2;
const shape = new THREE.Shape();
shape.moveTo(origin.x, origin.y);
shape.lineTo(origin.x + width, origin.y);
shape.lineTo(origin.x + width, origin.y + height);
shape.lineTo(origin.x, origin.y + height);

const extrudeLength = 10;
class CustomCurve extends THREE.Curve {
  getPoint(t) {
    return new THREE.Vector3(extrudeLength * t, 0, 0);
  }
}
const customPath = new CustomCurve();

const extrudeSettings = {
  bevelEnabled: false,
  steps: 1,
  extrudePath: customPath
};

const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
const material = new THREE.MeshBasicMaterial({ color: '#ff0000', wireframe: false });
const mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);




const vertices = [];
const positionAttribute = geometry.attributes.position;


for (let i = 0; i < positionAttribute.count; i++) {
  const x = positionAttribute.getX(i);
  const y = positionAttribute.getY(i);
  const z = positionAttribute.getZ(i);
  vertices.push([x, y, z]);
}

const uniqueVertices = [...new Set(vertices.map((v) => JSON.stringify(v)))].map(
  (v) => JSON.parse(v)
);

console.log(uniqueVertices);


const maxX = Math.max(...uniqueVertices.map((v) => v[0]));
const lastCrossSection = uniqueVertices.filter((v) => v[0] === maxX);

const previousXValues = uniqueVertices.map((v) => v[0]).filter((x) => x < maxX);
const secondMaxX = previousXValues.length > 0 ? Math.max(...previousXValues) : null;
const previousCrossSection = secondMaxX !== null ? uniqueVertices.filter((v) => v[0] === secondMaxX) : [];

// console.log("Last 4 Points:", lastCrossSection);
// console.log("Previous 4 Points:", previousCrossSection);

const distBetweenPointsPerpendicular = lastCrossSection[0][0] - previousCrossSection[0][0];
const distBetweenPointsBase = height;
// console.log(distBetweenPointsBase, distBetweenPointsPerpendicular);

let actualMaxAngle = Math.atan(distBetweenPointsPerpendicular / distBetweenPointsBase);
console.log(actualMaxAngle * (180 / Math.PI));

// debugger;

var angleDegrees = 28;
if (angleDegrees > (actualMaxAngle * (180 / Math.PI))) {
  angleDegrees = (actualMaxAngle * (180 / Math.PI));
}
// console.log(angleDegrees , actualMaxAngle);

const angleRadians = angleDegrees * (Math.PI / 180);
const distToMove = distBetweenPointsBase * Math.tan(angleRadians);



const v1 = [extrudeLength, 1, 1];
const v2 = [extrudeLength - distToMove, 1, 1];
const v3 = [extrudeLength, 1, -1];
const v4 = [extrudeLength - distToMove, 1, -1];

const v5 = [0, 1, -1];
const v6 = [0, 1, 1];
const v7 = [distToMove, 1, -1];
const v8 = [distToMove, 1, 1];


function distanceVector(v1, v2) {
  var dx = v1[0] - v2[0];
  var dy = v1[1] - v2[1];
  var dz = v1[2] - v2[2];

  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

var distance = distanceVector(v2, v8);
console.log(distance, - v8[0] + v2[0]);

if (distance > 0.09  && (- v8[0] + v2[0]) > 0 ) {

  for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.getX(i);
    const y = positionAttribute.getY(i);
    const z = positionAttribute.getZ(i);

    if (x === v1[0] && y === v1[1] && z === v1[2]) {
      positionAttribute.setXYZ(i, v2[0], v2[1], v2[2]);
    }
    if (x === v3[0] && y === v3[1] && z === v3[2]) {
      positionAttribute.setXYZ(i, v4[0], v4[1], v4[2]);
    }
  }

  for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.getX(i);
    const y = positionAttribute.getY(i);
    const z = positionAttribute.getZ(i);

    if (x === v5[0] && y === v5[1] && z === v5[2]) {
      positionAttribute.setXYZ(i, v7[0], v7[1], v7[2]);
    }
    if (x === v6[0] && y === v6[1] && z === v6[2]) {
      positionAttribute.setXYZ(i, v8[0], v8[1], v8[2]);
    }
  }
  positionAttribute.needsUpdate = true;
  geometry.computeVertexNormals();
  mesh.geometry = geometry;


  // const sphereGeometry1 = new THREE.SphereGeometry(0.1, 16, 16);
  // const sphereMaterial1 = new THREE.MeshBasicMaterial({ color: 0x000ff }); // Red
  // const sphere1 = new THREE.Mesh(sphereGeometry1, sphereMaterial1);
  // sphere1.position.set(v2[0], v2[1], v2[2]);
  // scene.add(sphere1);

  // const sphereGeometry2 = new THREE.SphereGeometry(0.1, 16, 16);
  // const sphereMaterial2 = new THREE.MeshBasicMaterial({ color: 0x000ff }); // Red
  // const sphere2 = new THREE.Mesh(sphereGeometry2, sphereMaterial2);
  // sphere2.position.set(v8[0], v8[1], v8[2]);
  // scene.add(sphere2);
}




const edgeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 80 });
const edges = new THREE.EdgesGeometry(geometry);
const line = new THREE.LineSegments(edges, edgeMaterial);
mesh.add(line);

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();
